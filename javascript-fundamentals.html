<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Fundamentals | Software Engineering Interview Guide</title>
    <link rel="stylesheet" href="assets/css/page-style.css">
</head>
<body>
    <div class="container">
        <header class="page-header">
            <h1 class="project-name"><a href="index.html">Software Engineering Interview Guide</a></h1>
            <p class="project-tagline">A friendly, no-bs place to refresh your brain before any technical interview</p>
        </header>

        <main class="main-content">
            <h1>‚è≥ javascript + typescript fundamentals</h1>

            <h2>var vs let vs const</h2>
            <ul>
                <li>var: old, function scoped, hoisted</li>
                <li>let: block-scoped, reassignable</li>
                <li>const: block-scoped, not reassignable</li>
            </ul>
            <pre><code>var car = "car"; // function scoped
let a = 5; // block scoped
const b = 1; // cannot reassign</code></pre>

            <h2>üåÄ scope, hoisting, closures</h2>
            <ul>
                <li>scope = where variables live</li>
                <li>hoisting = var + functions get "lifted" to top</li>
                <li>closures = inner function "remember" outer variables</li>
            </ul>

            <h3>üßô‚Äç‚ôÄÔ∏è Hoisting in JavaScript</h3>
            <p><strong>definition:</strong> hoisting is when JS "remembers" all your variables & function declarations <strong>before</strong> it actually runs the code.</p>

            <p><strong>memory allocation phase:</strong></p>
            <ul>
                <li>all <strong>var</strong>, <strong>function</strong>, and <strong>class</strong> declarations are stored in memory.</li>
                <li>JS does this automatically, <strong>before</strong> executing line-by-line.</li>
            </ul>

            <p><strong>key insights:</strong></p>
            <ul>
                <li>only declarations are hoisted - not initializations</li>
                <li><strong>let</strong> and <strong>const</strong> are hoisted too, but not accessible before declaration</li>
                <li>function declarations are hoisted fully, function expressions are not.</li>
            </ul>

            <h2>üß≥ Closures</h2>
            <p>a <strong>closure</strong> is when an inner function remembers the variables from its outer function, even after the outer function has finished running.</p>

            <p>they are not only in JS, but it means that functions <strong>enclose</strong> different variables that are there when the function is <strong>declared</strong>. And by <strong>enclosing</strong>, it means they <strong>remember</strong> them. So basically it means whenever you import or use a function, you <strong>also get by default</strong> all the <strong>scope</strong> where that function was created.</p>

            <p>so if there is a variable at the root level, the function has access to that forever, until you never use that function again.</p>
            <pre><code>const name = "Olga";

export function sayHello() {
  console.log(name);
}</code></pre>

            <p>If someone imports and runs this, the function will still work because even if they provide an argument or not, it will actually look in the function scope and then in the global and find this variable.</p>

            <p>Even if this variable is not present where this function is being called, as long as it's present in the module ‚Äî (name = "Olga" still shows).</p>

            <p>Another way you could show this is if you return another function. Let's say you actually create:</p>
            <pre><code>export function createSayHello() {
  const name = "Olga"; // now 'name' is in the scope of createSayHello

  return function sayHello() {
    console.log(name);
  }
}</code></pre>

            <p>then:</p>
            <pre><code>const sayHelloOlga = createSayHello();
sayHelloOlga(); // still works ‚úÖ</code></pre>

            <p>so scope is basically whatever you see that is surrounded by curly brackets {}. So if I use sayHello outside here, it will still work.</p>

            <p>Let's rewrite the full example again just to make it clearer:</p>
            <pre><code>export function createSayHello() {
  // 'name' was enclosed by sayHello
  const name = "Olga";

  return function sayHello() {
    console.log(name);
  };
}

const sayHelloOlga = createSayHello();
sayHelloOlga(); // still works</code></pre>

            <p>i would get no <strong>exception</strong>, even if in the <strong>scope I do not have a name</strong>. So the function is using a variable called name. it is not present in this global scope. however, because the function was created in this scope, it has access to this variable.</p>

            <p>so that is <strong>closure</strong> ‚Äî because we can say that name was enclosed by sayHello.
            you do not <strong>only get the function ‚Äî you get the whole scope</strong>, the whole lexical environment üåç</p>

            <p>used for data privacy, stateful functions, and async logic.</p>

            <h3>‚ö†Ô∏è what is the drawback of this?</h3>
            <p>it puts a lot of <strong>pressure on memory</strong> üß† because everything that is in the scope is still referenced by this function as long as the function is being used.</p>

            <p>so we cannot <strong>remove</strong> it from <strong>memory</strong>, we cannot release that memory by the <strong>garbage collection</strong> algorithm.</p>

            <p>so basically, <strong>JavaScript cannot clean it up</strong> ‚Äî it cannot get rid of anything that is in the <strong>closure</strong> scope of this function. and that means you put a lot of pressure on memory.</p>

            <p>that is why traditionally we all know that JavaScript is not a super memory-efficient language ‚Äî it actually needs a lot of <strong>RAM memory</strong> üíæ.</p>

            <h2>üìê types, interfaces, generics (typescript)</h2>

            <h3>üß© types</h3>
            <pre><code>let age: number = 25;
let name: string = Olga;
let isAdmin: boolean = true;</code></pre>

            <h3>üß∑ Interfaces</h3>
            <pre><code>interface User {
    id: number;
    name: string;
}

const user: User = {id: 1; name: "Olga" };</code></pre>

            <h3>üéÅ Generics</h3>
            <pre><code>function wrapInArray&lt;T&gt;(value: T): T[] {
    return [value];
}

const nums = wrapInArray&lt;number&gt;(5); // [5]</code></pre>

            <h2>üì¶ objects, arrays, maps, sets</h2>

            <h3>Objects</h3>
            <p>Key-value pairs</p>
            <pre><code>const user = { name: "Alex", age: 22};</code></pre>

            <h3>Arrays</h3>
            <p>Ordered collections</p>
            <pre><code>const numbers = [1, 2, 3];</code></pre>

            <h3>Maps</h3>
            <p>Key-value with any type keys</p>
            <pre><code>const map = new Map();
map.set("a", 1);</code></pre>

            <h3>Sets</h3>
            <p>Unique values only</p>
            <pre><code>const set = new Set([1, 2, 2, 3]) // {1, 2, 3}</code></pre>

            <h2>üèõÔ∏è classes, inheritance, this</h2>
            <pre><code>class Animal {
    constructor(public name: string) {}

    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks`);
    }
}

const d = new Dog("Rex");
d.speak(); // Rex barks</code></pre>

            <p><strong>this</strong> keyword</p>
            <ul>
                <li>refers to the current context(object, function or global)</li>
                <li>arrow function don't have their own <strong>this</strong></li>
            </ul>

            <h2>common gotchas & tricks</h2>
            <p>‚ùå Don't use == ‚Üí use === for strict equality<br>
            ‚úÖ Use ?. (optional chaining) to safely access properties<br>
            ‚úÖ Use destructuring for cleaner code<br>
            ‚úÖ Prefer const by default, only use let when needed<br>
            ‚ùå Avoid mutating objects/arrays directly ‚Äì prefer immutability</p>
        </main>

        <footer>
            <div class="social-links">
                <a href="https://linkedin.com/in/olganedelcu/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                    </svg>
                </a>
                <a href="https://github.com/olganedelcu" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
                    </svg>
                </a>
                <a href="https://olgaconstantina.hashnode.dev" target="_blank" rel="noopener noreferrer" aria-label="Hashnode">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.351 8.019l-6.37-6.37a5.63 5.63 0 0 0-7.962 0l-6.37 6.37a5.63 5.63 0 0 0 0 7.962l6.37 6.37a5.63 5.63 0 0 0 7.962 0l6.37-6.37a5.63 5.63 0 0 0 0-7.962zM12 15.953a3.953 3.953 0 1 1 0-7.906 3.953 3.953 0 0 1 0 7.906z"/>
                    </svg>
                </a>
                <a href="https://medium.com/@olganedelcuam" target="_blank" rel="noopener noreferrer" aria-label="Medium">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M13.54 12a6.8 6.8 0 01-6.77 6.82A6.8 6.8 0 010 12a6.8 6.8 0 016.77-6.82A6.8 6.8 0 0113.54 12zM20.96 12c0 3.54-1.51 6.42-3.38 6.42-1.87 0-3.39-2.88-3.39-6.42s1.52-6.42 3.39-6.42 3.38 2.88 3.38 6.42M24 12c0 3.17-.53 5.75-1.19 5.75-.66 0-1.19-2.58-1.19-5.75s.53-5.75 1.19-5.75C23.47 6.25 24 8.83 24 12z"/>
                    </svg>
                </a>
            </div>
            <p>Made with ‚ù§Ô∏è by Olga Nedelcu</p>
        </footer>
    </div>
</body>
</html>
